/*CCU U1 Code
   This code programs the main CPU on the CCU board. The CPU will perform the followings
   1. Open a virtual COM port for PC and T/R commands and data with the PC
   2. It will create serial controll commands for the U6, and receive U6 stats (other arduino on the CCU board)
   3. It Connect and controll all the cards
   4. will monitor negative voltage, HV 1 and HV2
   5. will count the sequences

*/

//Includes
#include <Arduino.h>
#include "wiring_private.h"

//Definitions
#define SigGen Serial1    // communication port between signal generator and the hub
#define Card1 Serial2     // Card port
#define Card2 Serial3     // Card port
#define Card3 Serial4     // Card port
#define Card4 Serial5     // Card port
#define PC Serial         // Virtual serial


//CAN bus definition here!!!


//Timre Setup!
IntervalTimer ledBlinkTimer; // for HV LED!
IntervalTimer SleepNocommandTimer; // if connection is lost, goto safety mode!



//pre-setup commands
//Pin namings
const byte VoltageOKPin = 2;    // this pin is input, will be 1 when negative power supply is connected.
const byte TriggerPin = 3;       // TriggerPin 1 input will be here,cards will have totally different TriggerPin generated by SigGen
const byte SigGenOKPin = 4;      // this pin is Output and will give sumbs UP, if 1, then SigGen will work!
const byte VPPenablePin = 5;     // Enable output for VPP, OUtput
const byte VNNenablePin = 6;
const byte Card1OKPin = 12;      // input, will be TriggerPined by card!
const byte Card2OKPin = 11;
const byte Card3OKPin = 10;
const byte Card4OKPin = 9;
const byte HVLEDPin = 13;
const int VPPreadPin = A4;
const int VNNreadPin = A5;


//Serial assignments



//Variable bank!
volatile byte VNN = 0;
volatile byte VPP = 0;
volatile word VPPc = 0;
volatile word VNNc = 0;


volatile bool VPPenable = false;
volatile bool VNNenable = false;
volatile bool VPPactive = false; //if PS output is ON or OFF, will be read from SigGen command
volatile bool VNNactive = false;

volatile byte VPPread = 0;
volatile byte VNNread = 0; // contains read voltage
 byte VNNc1 = 0;
 byte VPPc1 = 0;
 byte VNNc2 = 0;
 byte VPPc2 = 0;
 byte VNNc3 = 0;
 byte VPPc3 = 0;
 byte VNNc4 = 0;
 byte VPPc4 = 0;

volatile bool ImgMd;
volatile bool STOP = true; // at the beginning stop signal generation
volatile bool Intiation; // this will be 1 if it is not initiating! zero for the begining, zero it after receving Seq form PC
volatile bool Operation;
volatile word TrOd = 50; //Dummy value
volatile word Qswitch = 500;

volatile bool HVLED = 0; // will used for controlling the LED!
volatile bool VoltageOK = false; // if negative voltage is appled!
volatile bool Card1status = 0; // cards status will be here!
volatile bool Card2status = 0; // cards status will be here!
volatile bool Card3status = 0; // cards status will be here!
volatile bool Card4status = 0; // cards status will be here!
byte PCResponce[64]; // this will contain the most up to date card info ready to send!
byte SigGenResponce[64]; // this contain the most up to date info for the signal generator!
volatile word SeqCount = 0;
// byte Card1Seq[512][32];//all the squence information for the card 1
// byte Card2Seq[512][32];//all the squence information for the card 2
// byte Card3Seq[512][32];//all the squence information for the card 3
// byte Card4Seq[512][32];//all the squence information for the card 4
//byte PCseq[2048][64];   //this will store all the sequence information
byte PCSettings[64];
volatile bool SettingPending = false;
volatile bool VoltageSettingsPending = false;
bool CardPogrammingPending = false;
bool ManulaTimerStatus = false;  //this bit is used to generate delay without keeping the CPU Busy!
unsigned long SnappedTime = 0;
unsigned long SnappedTimeforPCconnection = 0;
volatile word MaxSeq = 0;          //this will be updated as soons as we receive the sequence bytes
unsigned long currentTime = 0;
volatile bool HVlevelError = false;
byte Array[2];


//Initiation **********************************************************************************************************************************Setup
void setup() {
  //Serial Port conection----------------------------------------------------------------------------------------------------------------------Serial port config
  PC.begin(9600);
  PC.setTimeout(1);
  SigGen.begin(9600);

  Card1.begin(9600);

  Card2.begin(9600);

  Card3.begin(9600);

  Card4.begin(9600);

  //Pin Mode!----------------------------------------------------------------------------------------------------------------------------------- pin mode config
  pinMode(SigGenOKPin, OUTPUT);
  pinMode(VPPenablePin, OUTPUT);
  pinMode(VNNenablePin, OUTPUT);
  pinMode(HVLEDPin, OUTPUT);
  pinMode(VoltageOKPin, INPUT);
  pinMode(TriggerPin, INPUT_PULLUP);
  pinMode(Card1OKPin, INPUT_PULLUP);
  pinMode(Card2OKPin, INPUT_PULLUP);
  pinMode(Card3OKPin, INPUT_PULLUP);
  pinMode(Card4OKPin, INPUT_PULLUP);

  //Logicwrite on pins!--------------------------------------------------------------------------------------------------------------------------- pin logic
  digitalWrite(SigGenOKPin, HIGH);
  digitalWrite(VPPenablePin, LOW);
  digitalWrite(VNNenablePin, LOW);
  digitalWrite(HVLEDPin, LOW);



  //timre setups!---------------------------------------------------------------------------------------------------------------------------------- timers
  ledBlinkTimer.begin(blinkLED, 50000);
  SleepNocommandTimer.begin(SleepNocommand, 1000000);  //one second!

  //interupts-------------------------------------------------------------------------------------------------------------------------------------- Interrups
  attachInterrupt(digitalPinToInterrupt(TriggerPin), Trigger1Interrup, RISING);   // main trigger, if comes in and CCU confirms, a delayed trigger out will be created and counted
  // attachInterrupt(digitalPinToInterrupt(Card1OKPin), Card1OKPinInterrup, RISING); // cards interrups!
  // attachInterrupt(digitalPinToInterrupt(Card2OKPin), Card2OKPinInterrup, RISING);
  // attachInterrupt(digitalPinToInterrupt(Card3OKPin), Card3OKPinInterrup, RISING);
  // attachInterrupt(digitalPinToInterrupt(Card4OKPin), Card4OKPinInterrup, RISING);



}



//Main *****************************************************************************************************************************************
void loop() {
  //Initial reads-------------------------------------------------------------------------------------------------------------------------------- read pins!
  VoltageOK = digitalRead(VoltageOKPin);            // will read the VoltageOKPin, it will be true if there is negative voltage!
  Card1status = !digitalRead(Card1OKPin);            //Cards will make this pin zero, so inverted!
  Card2status = !digitalRead(Card2OKPin);
  Card3status = !digitalRead(Card3OKPin);
  Card4status = !digitalRead(Card4OKPin);
  digitalWrite(SigGenOKPin, !STOP);

  readHVvoltages();                                   //read HV from capacitors
  if (!VoltageOK) {                             //if negative voltage is missing!
    STOP = 1;
  }
  //simple commands!----------------------------------------------------------------------------------------------------------------------------- LED for HV
  if (((VPPread > 25) || (VNNread > 25)) && VoltageOK == true) { //Contoll LED on board and blink if there is HV!
    HVLED = true;
  } else {
    HVLED = false;
  }
  if (SettingPending == true) {
    extractPCsettings();
    prepareBytesForTransfer();
    SettingPending = false;
    SigGen.write(SigGenResponce, 64);
  }
  if (VoltageSettingsPending == true) {
    prepareBytesForTransfer();
    VoltageSettingsPending = false;
    SigGen.write(SigGenResponce, 64);
  }

  if (CardPogrammingPending) { //last sequence came from the PC! we should wait 100ms without keeping the CPU busy! and then perfomr a programming sequence!
    ManulaTimerStatus = true;
    SnappedTime = millis();
    CardPogrammingPending = false;
  }

  //-------------------------------------------------------------------------------------------------------------------------------------------- manula timer
  if ((ManulaTimerStatus == true) && ((SnappedTime + 200) > millis())) {                //this will wait 200ms after the last sequence came in
    ManulaTimerStatus = false;                                                           //only do it one time for evey sequence package
    //   calculateCardsInfo();                                                                //extract the information
    //   respondToCard1command();                                                                      //program cards
    //   respondToCard2command();
    //   respondToCard3command();
    //   respondToCard4command();
  }

  //---------------------------------------------------------------------------------------------------------------------------------------------check everything and process!

  //update the serial buffers and be ready to send!---------------------------------------------------------------------------------------------- calculate serials
  prepareBytesForTransfer();   //
/*
  if (Intiation) {
    if ((VPPread > VPP + 5) || (VPPread < VPP - 5) || (VNNread > VNN + 5) || (VNNread < VNN - 5)) {
      STOP = true;
      VPPenable = false;
      VNNenable = false;
      HVlevelError = true;
    } else {
      HVlevelError = false;
    }
  }
  */
  digitalWrite(VPPenablePin, VPPenable);
  digitalWrite(VNNenablePin, VNNenable);



  //Check Serials ------------------------------------------------------------------------------------------------------------------------------- chech input serials
  if (PC.available() > 0) {  //if PC sent something
    respondToPCcommand();
  }
  //if (SigGen.available() > 0) {  //if PC sent something
  //  respondToSigGencommand();
  //}
    if(!Card1status){
    VNNc1=0;
    VPPc1=0;
    }
    if(!Card2status){
    VNNc2=0;
    VPPc2=0;
    }
    if(!Card3status){
    VNNc3=0;
    VPPc3=0;
    }
    if(!Card4status){
    VNNc4=0;
    VPPc4=0;
    }
    if (Card1.available() > 0) {  //if Card 1 sent something
    Card1.readBytes(Array,2);
    VPPc1=Array[0];
    VNNc1=Array[1];

    }
 
    if (Card2.available() > 0) {  //if Card 1 sent something
          Card2.readBytes(Array,2);
    VPPc2=Array[0];
    VNNc2=Array[1];
    }
    if (Card3.available() > 0) {  //if Card 1 sent something
          Card3.readBytes(Array,2);
    VPPc3=Array[0];
    VNNc3=Array[1];
    }
    if (Card4.available() > 0) {  //if Card 1 sent something
          Card4.readBytes(Array,2);
    VPPc4=Array[0];
    VNNc4=Array[1];
    }

  currentTime = millis();
}                                            //LOOP end!

//Functions ***************************************************************************************************************************************
//LED blink function!
void blinkLED(void) {
  if (HVLED) {
    digitalWrite(HVLEDPin, !digitalRead(HVLEDPin));
  } else {
    digitalWrite(HVLEDPin, LOW);
  }
}

//readHV
void readHVvoltages(void) {                 // done
  int readinput;
  readinput = analogRead(VPPreadPin);
  VPPread = readinput * 0.477;
  readinput = analogRead(VNNreadPin);
  VNNread = readinput * 0.806451612903;
}

// Trigger Interrups
void Trigger1Interrup (void) {            // done- need test

  SeqCount++;
  if (SeqCount > MaxSeq) {
    SeqCount = 0;
  }
  if (!Intiation) {
    SeqCount = 0;    // if we received new sequence, this will be zero, so we can start from seq 0!
    Intiation = 1;  // it is initiated!, it it can count again!
  }
}


//PC sent command
void respondToPCcommand(void) {           // done- need test
  byte inKey[64] = {54, 122, 105, 105, 101, 117, 74, 108, 85, 101, 55, 107, 97, 109, 104, 78, 97, 52, 115, 104, 112, 82, 102, 103, 122, 67, 98, 106, 66, 55, 84, 118, 119, 48, 68, 65, 105, 100, 74, 49, 102, 71, 57, 100, 81, 103, 82, 80, 56, 55, 87, 110, 79, 50, 114, 98, 117, 115, 108, 84, 110, 50, 101, 50};
  byte outKey[64] = {54, 101, 116, 116, 117, 74, 108, 85, 101, 55, 107, 97, 109, 104, 78, 97, 52, 115, 104, 112, 82, 102, 103, 122, 67, 98, 106, 66, 55, 101, 114, 121, 48, 68, 65, 105, 100, 74, 49, 102, 71, 57, 100, 81, 103, 82, 80, 56, 55, 87, 110, 79, 50, 114, 99, 97, 114, 108, 84, 110, 50, 101, 111, 50};
  byte inbytes[64];
  byte A;
  byte B[32];
  word S;
  word G;
  byte localVPP;
  byte localVNN;
  bool Error = false;
  PC.readBytes(inbytes, 64);
  if (inbytes[0] == 54 && inbytes[1] == 122 && inbytes[2] == 105) {
    for (byte i = 0; i < 64; i++) {
      if (inbytes[i] != inKey[i]) {
        Error = true;
      }
    }
    if (!Error) {
      PC.write(outKey, 64);
    }
  }
  if (inbytes[0] == 83 && inbytes[1] == 69 && inbytes[2] == 81) { //it is a sequence!
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<code here
    //we have to extract the sequence number and store it in the proper
    // we can extract the current sequence and if it is the same as last sequence, we can initiate a card programing sequence!
    STOP = true; //Stop the process


    //for (byte i=0;i<64;i++){
    //PCseq[S][i]=inbytes[i];
    //}
    //OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO

    //inbytes[0] to 63



    //copy the info
    //   for (byte j = 0; j < 64; j++) {
    //     A[j] = PCseq[i][j];
    //   }
    //BUILT STRUCTURE!
    B[0] = 66;  //'b'
    B[1] = 105; //'i'
    B[2] = 116; //'t'
    B[3] = 128; //non ASCII, filler!

    //extract the current sequence
    S = (inbytes[11] - 48) * 1000;
    S = S + ((inbytes[12] - 48) * 100);
    S = S + ((inbytes[13] - 48) * 10);
    S = S + ((inbytes[14] - 48));
    G = (inbytes[15] - 48) * 1000;
    G = G + ((inbytes[16] - 48) * 100);
    G = G + ((inbytes[17] - 48) * 10);
    G = G + ((inbytes[18] - 48));
    MaxSeq = G;

    B[4] = highByte(S);
    B[5] = lowByte(S);
    B[6] = 128; //non ASCII, filler!
    B[7] = highByte(MaxSeq);
    B[8] = lowByte(MaxSeq);
    B[9] = 128; //non ASCII, filler!

    //extract the settings
    for (byte k = 0; k < 16; k++) {
      bitWrite(B[k + 10], 7, bitRead(inbytes[(k * 2) + 19], 0)); //start fom byte 10 and write up to byte 25!, will extract fom byte 19 to 50
      bitWrite(B[k + 10], 6, bitRead(inbytes[(k * 2) + 19], 1));
      bitWrite(B[k + 10], 5, bitRead(inbytes[(k * 2) + 19], 2));
      bitWrite(B[k + 10], 4, bitRead(inbytes[(k * 2) + 19], 3));
      bitWrite(B[k + 10], 3, bitRead(inbytes[(k * 2) + 20], 0));
      bitWrite(B[k + 10], 2, bitRead(inbytes[(k * 2) + 20], 1));
      bitWrite(B[k + 10], 1, bitRead(inbytes[(k * 2) + 20], 2));
      bitWrite(B[k + 10], 0, bitRead(inbytes[(k * 2) + 20], 3));
    }

    //fill the rest! reserved for future!
    for (byte k = 26; k < 32; k++) {
      B[k] = 128; //non ASCII, filler!
    }

    //place the structure in the correct card holder
    switch (inbytes[9]) {
      case 65:                 // if this is for Card 1
        if (!digitalRead(Card1OKPin)){
          Card1.write(B, 32);
        }

        break;
      case 66:                 // if this is for Card 2
        if (!digitalRead(Card2OKPin)){
          Card2.write(B, 32);
        }
        break;
      case 67:                 // if this is for Card 3
        if (!digitalRead(Card3OKPin)){
          Card3.write(B, 32);
        }
        break;
      case 68:                 // if this is for Card 4
        if (!digitalRead(Card4OKPin)){
          Card4.write(B, 32);
        }
        break;
    }

    //OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
    S = (inbytes[59] - 48) * 1000;
    S = S + ((inbytes[60] - 48) * 100);
    S = S + ((inbytes[61] - 48) * 10);
    S = S + ((inbytes[62] - 48));

    G = G * 4;
    if (S == G) {
      MaxSeq = G / 4;
      CardPogrammingPending = true; //if the last sequence came in, we have to perform a card programming sequnce.
    }
    PC.write(inbytes, 64);
  }
  if (inbytes[0] == 67 && inbytes[1] == 67 && inbytes[2] == 85) { //it is a settings
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<code here
    //we have to extract the sequence number and store it in the proper
    for (byte i = 0; i < 64; i++) {
      PCSettings[i] = inbytes[i];

    }
    VPPactive = true;
    VNNactive = true;
    SettingPending = true;
    PC.write(inbytes, 64);

  }
  if (inbytes[0] == 85 && inbytes[1] == 112 && inbytes[2] == 100) { // update Command
    //CODE HERE
    A = inbytes[10] - 48;
    STOP = bitRead(A, 0);
    A = inbytes[11] - 48;
    Operation = bitRead(A, 0);
    A = inbytes[12] - 48;
    Intiation = bitRead(A, 0);
    // PC.write(inbytes,64);
    localVPP = inbytes[15] - 1;
    localVNN = inbytes[16] - 1;
    if ((localVPP != VPP) || (localVNN != VNN)) {
      STOP = 1;
      VPP = localVPP;
      VNN = localVNN;
      VoltageSettingsPending = true;
    } else {
      if (STOP) {
        VPPenable = false;
        VNNenable = false;
      } else {
        VPPenable = true;
        VNNenable = true;
      }
    }
    PC.write(PCResponce, 64);
  }
  SnappedTimeforPCconnection = millis();
  SleepNocommandTimer.begin(SleepNocommand, 1000000);  //one second!
}

//Signal generator sent command
void respondToSigGencommand(void) {        // done-need test
  byte A[64];
  byte C = 0;
  while (C == 0) {
    SigGen.write(SigGenResponce, 64);
    C++;
    while (SigGen.available() == 0);
    SigGen.readBytes(A, 64);
    for (byte y = 0; y < 32; y++) { //check bytes one by one!
      if (A[y] != SigGenResponce[y]) {
        C = 0;                        //repeat the send!! if there is wrong info
      }
    }
  }

}


  

  /*
  //Card 2 sent command
  void respondToCard2command(void) {         // done-need test
  byte A[32];
  byte C=0;
  byte j=0;

  while((C<MaxSeq)&&(!digitalRead(Card2OKPin))) {
    Card2.write(Card2Seq[C],32);
    while(Card2.available()==0);
    Card2.readBytes(A, 32);
    C++;
    j=C-1;
    for (byte y = 0; y < 32; y++){ //check bytes one by one!
     if (A[y]!=Card2Seq[C][y]){
     C=j;                          //repeat the send!! if there is wrong info
     }
    }
  }
  }
  //Card 3 sent command
  void respondToCard3command(void) {         // done-need test
  byte A[32];
  byte C=0;
  byte j=0;

  while((C<MaxSeq)&&(!digitalRead(Card3OKPin))) {
    Card3.write(Card3Seq[C],32);
    while(Card3.available()==0);
    Card3.readBytes(A, 32);
    C++;
    j=C-1;
    for (byte y = 0; y < 32; y++){ //check bytes one by one!
     if (A[y]!=Card3Seq[C][y]){
     C=j;                          //repeat the send!! if there is wrong info
     }
    }
  }
  }
  //Card 4 sent command
  void respondToCard4command(void) {         // done-need test
  byte A[32];
  byte C=0;
  byte j=0;

  while((C<MaxSeq)&&(!digitalRead(Card4OKPin))) {
    Card4.write(Card4Seq[C],32);
    while(Card4.available()==0);
    Card4.readBytes(A, 32);
    C++;
    j=C-1;
    for (byte y = 0; y < 32; y++){ //check bytes one by one!
     if (A[y]!=Card4Seq[C][y]){
     C=j;                          //repeat the send!! if there is wrong info
     }
    }
  }
  }
*/
/*Prepare the buffers and update them!

  what needs to be update:
    1. Update Responce for PC
    2. Update responce for SigGen
    3. General Update responce for Cards

    Structure for PC responcs (ALL az Char)
    Byte 0 to 9 > 'UpdateComm'
    byte 10:13 > reserved (48)
    byte 14 > VNNenable  (48 if disable, 49 if enabled)
    byte 15 > VPPenable  (48 if disable, 49 if enabled)
    byte 16 > VNNactive
    byte 17 > VPPactive
    byte 18:20 > VNN read
    byte 21:23 > VPP read
    byte 24  > Card 1 connect
    byte 25  > Card 2 connect
    byte 26  > Card 3 connect
    byte 27  > Card 4 connect
    byte 28:30 > Card 1 VNN
    byte 31:33 > Card 1 VPP
    byte 34:36 > Card 2 VNN
    byte 37:39 > Card 2 VPP
    byte 40:42 > Card 3 VNN
    byte 43:45 > Card 3 VPP
    byte 46:48 > Card 4 VNN
    byte 49:51 > Card 4 VPP
    byte 52:55 > currentSequence
    byte 56:63  > reserved (48)

    Structure for Signal Generator
    byte 0:5 > 'SigGen'
    byte 6   > STOP
    byte 7   > ImgMd
    byte 8   > Intiation
    byte 9   > Operation
    byte 10:11> TrOd
    byte 12:13> Qswitch
    byte 14> VPP
    byte 15> VNN
    byte 16:17>VPPc
    byte 18:19>VNNc
    byte 20:64> reserved


*/
void prepareBytesForTransfer(void) {       // done-need test

  //preparePC command!
  PCResponce[0] = 85;
  PCResponce[1] = 112;
  PCResponce[2] = 100;
  PCResponce[3] = 97;
  PCResponce[4] = 116;
  PCResponce[5] = 101;
  PCResponce[6] = 67;
  PCResponce[7] = 111;
  PCResponce[8] = 109;
  PCResponce[9] = 109;
  PCResponce[10] = 48;
  PCResponce[11] = 48;
  PCResponce[12] = 48;
  PCResponce[13] = 48;
  PCResponce[14] = 48 + VNNenable;
  PCResponce[15] = 48 + VPPenable;
  PCResponce[16] = 48 + VNNactive;
  PCResponce[17] = 48 + VPPactive;
  PCResponce[18] = (VNNread / 100) + 48;
  PCResponce[19] = ((VNNread - ((PCResponce[18] - 48) * 100)) / 10) + 48;
  PCResponce[20] = (VNNread - (((PCResponce[18] - 48) * 100) + ((PCResponce[19] - 48) * 10))) + 48;
  PCResponce[21] = (VPPread / 100) + 48;
  PCResponce[22] = ((VPPread - ((PCResponce[21] - 48) * 100)) / 10) + 48;
  PCResponce[23] = (VPPread - (((PCResponce[21] - 48) * 100) + ((PCResponce[22] - 48) * 10))) + 48;
  PCResponce[24] = 48 + Card1status;
  PCResponce[25] = 48 + Card2status;
  PCResponce[26] = 48 + Card3status;
  PCResponce[27] = 48 + Card4status;
  PCResponce[28] = (VNNc1 / 100) + 48;
  PCResponce[29] = ((VNNc1 - ((PCResponce[28] - 48) * 100)) / 10) + 48;
  PCResponce[30] = (VNNc1 - (((PCResponce[28] - 48) * 100) + ((PCResponce[29] - 48) * 10))) + 48;
  PCResponce[31] = (VPPc1 / 100) + 48;
  PCResponce[32] = ((VPPc1 - ((PCResponce[31] - 48) * 100)) / 10) + 48;
  PCResponce[33] = (VPPc1 - (((PCResponce[31] - 48) * 100) + ((PCResponce[32] - 48) * 10))) + 48;
  PCResponce[34] = (VNNc2 / 100) + 48;
  PCResponce[35] = ((VNNc2 - ((PCResponce[34] - 48) * 100)) / 10) + 48;
  PCResponce[36] = (VNNc2 - (((PCResponce[34] - 48) * 100) + ((PCResponce[35] - 48) * 10))) + 48;
  PCResponce[37] = (VPPc2 / 100) + 48;
  PCResponce[38] = ((VPPc2 - ((PCResponce[37] - 48) * 100)) / 10) + 48;
  PCResponce[39] = (VPPc2 - (((PCResponce[37] - 48) * 100) + ((PCResponce[38] - 48) * 10))) + 48;
  PCResponce[40] = (VNNc3 / 100) + 48;
  PCResponce[41] = ((VNNc3 - ((PCResponce[40] - 48) * 100)) / 10) + 48;
  PCResponce[42] = (VNNc3 - (((PCResponce[40] - 48) * 100) + ((PCResponce[41] - 48) * 10))) + 48;
  PCResponce[43] = (VPPc3 / 100) + 48;
  PCResponce[44] = ((VPPc3 - ((PCResponce[43] - 48) * 100)) / 10) + 48;
  PCResponce[45] = (VPPc3 - (((PCResponce[43] - 48) * 100) + ((PCResponce[44] - 48) * 10))) + 48;
  PCResponce[46] = (VNNc4 / 100) + 48;
  PCResponce[47] = ((VNNc4 - ((PCResponce[46] - 48) * 100)) / 10) + 48;
  PCResponce[48] = (VNNc4 - (((PCResponce[46] - 48) * 100) + ((PCResponce[47] - 48) * 10))) + 48;
  PCResponce[49] = (VPPc4 / 100) + 48;
  PCResponce[50] = ((VPPc4 - ((PCResponce[49] - 48) * 100)) / 10) + 48;
  PCResponce[51] = (VPPc4 - (((PCResponce[49] - 48) * 100) + ((PCResponce[50] - 48) * 10))) + 48;
  PCResponce[52] = (SeqCount / 1000) + 48;
  PCResponce[53] = ((SeqCount - ((PCResponce[52] - 48) * 1000)) / 100) + 48;
  PCResponce[54] = ((SeqCount - ((PCResponce[52] - 48) * 1000) + (PCResponce[53] - 48) * 100)) / 10 + 48;
  PCResponce[55] = (SeqCount - ((PCResponce[52] - 48) * 1000) + ((PCResponce[53] - 48)  * 100) + ((PCResponce[54] - 48)  * 10)) + 48;
  PCResponce[56] = 48;
  PCResponce[57] = 48;
  PCResponce[58] = 48;
  PCResponce[59] = 48;
  PCResponce[60] = 48 + HVlevelError;
  PCResponce[61] = 48 + VoltageOK;
  PCResponce[62] = 48 + STOP;
  PCResponce[63] = 48;

  //SigGen Command Preperation
  SigGenResponce[0] = 83;
  SigGenResponce[1] = 105;
  SigGenResponce[2] = 103;
  SigGenResponce[3] = 71;
  SigGenResponce[4] = 101;
  SigGenResponce[5] = 110;
  SigGenResponce[6] = 48 + STOP;
  SigGenResponce[7] = 48 + ImgMd;
  SigGenResponce[8] = 48 + Intiation;
  SigGenResponce[9] = 48 + Operation;
  SigGenResponce[10] = highByte(TrOd);
  SigGenResponce[11] = lowByte(TrOd);
  SigGenResponce[12] = highByte(Qswitch);
  SigGenResponce[13] = lowByte(Qswitch);
  SigGenResponce[14] = VPP;
  SigGenResponce[15] = VNN;
  SigGenResponce[16] = highByte(VPPc);
  SigGenResponce[17] = lowByte(VPPc);
  SigGenResponce[18] = highByte(VNNc);
  SigGenResponce[19] = lowByte(VNNc);
  SigGenResponce[20] = VPPactive + 48;
  SigGenResponce[21] = VNNactive + 48;
  for (int i = 22; i < 64; i++) {
    SigGenResponce[i] = 48;
  }
}

/*calculating the sequences for all cards!
  PCseq will contain exact copy of input sequence info
    there will four times arrays comming!
    every card has their own settings!
    Card 1 > byte 9 will be 65
    Card 2 > byte 9 will be 66
    Card 3 > byte 9 will be 67
    Card 4 > byte 9 will be 68
*/
/*
  void calculateCardsInfo(void) {                               // done-need test
  //MaxSeq;
  byte A[64];
  byte B[32];  // stores the extracted bytes and will be stored in cards acumulator
  word S;      //contains the current sequnece
  word LocMaxSeq = MaxSeq * 4;  //contains the actual received number of the sequences

  for (word i = 0; i < LocMaxSeq; i++) {
    //copy the info
    for (byte j = 0; j < 64; j++) {
      A[j] = PCseq[i][j];
    }
    //BUILT STRUCTURE!
    B[0] = 66;  //'b'
    B[1] = 105; //'i'
    B[2] = 116; //'t'
    B[3] = 128; //non ASCII, filler!

    //extract the current sequence
    S = (A[11] - 48) * 1000;
    S = S + ((A[12] - 48) * 100);
    S = S + ((A[13] - 48) * 10);
    S = S + ((A[13] - 48));

    B[4] = highByte(S);
    B[5] = lowByte(S);
    B[6] = 128; //non ASCII, filler!
    B[7] = highByte(MaxSeq);
    B[8] = lowByte(MaxSeq);
    B[9] = 128; //non ASCII, filler!

    //extract the settings
    for (byte k = 0; k < 16; k++) {
      bitWrite(B[k + 10], 0, bitRead(A[(k * 2) + 19], 0)); //start fom byte 10 and write up to byte 25!, will extract fom byte 19 to 50
      bitWrite(B[k + 10], 1, bitRead(A[(k * 2) + 19], 1));
      bitWrite(B[k + 10], 2, bitRead(A[(k * 2) + 19], 2));
      bitWrite(B[k + 10], 3, bitRead(A[(k * 2) + 19], 3));
      bitWrite(B[k + 10], 4, bitRead(A[(k * 2) + 20], 0));
      bitWrite(B[k + 10], 5, bitRead(A[(k * 2) + 20], 1));
      bitWrite(B[k + 10], 6, bitRead(A[(k * 2) + 20], 2));
      bitWrite(B[k + 10], 7, bitRead(A[(k * 2) + 20], 3));
    }

    //fill the rest! reserved for future!
    for (byte k = 26; k < 32; k++) {
      B[k] = 128; //non ASCII, filler!
    }

    //place the structure in the correct card holder
    switch (A[9]) {
      case 65:                 // if this is for Card 1
        for (byte j = 0; j < 32; j++) {
          Card1Seq[S][j] = B[j];
        }
        break;
      case 66:                 // if this is for Card 2
        for (byte j = 0; j < 32; j++) {
          Card2Seq[S][j] = B[j];
        }
        break;
      case 67:                 // if this is for Card 3
        for (byte j = 0; j < 32; j++) {
          Card3Seq[S][j] = B[j];
        }
        break;
      case 78:                 // if this is for Card 4
        for (byte j = 0; j < 32; j++) {
          Card4Seq[S][j] = B[j];
        }
        break;
    }
  }
  }
*/
void extractPCsettings (void) {
  //PCSettings
  VNN = PCSettings[3] + 1;
  VPP = PCSettings[4] - 1;
  VPPc = ((PCSettings[5] - 48) * 100) + ((PCSettings[6] - 48) * 10) + ((PCSettings[7] - 48));
  VNNc = ((PCSettings[8] - 48) * 100) + ((PCSettings[9] - 48) * 10) + ((PCSettings[10] - 48));
  ImgMd = bitRead(PCSettings[11], 3);   //zero  US, ONE> PA
  STOP = bitRead(PCSettings[11], 2);
  Intiation = bitRead(PCSettings[11], 1);
  Operation = bitRead(PCSettings[11], 0);
  TrOd = ((PCSettings[12] - 48) * 1000) + ((PCSettings[13] - 48) * 100) + ((PCSettings[14] - 48) * 10) + ((PCSettings[15] - 48));
  Qswitch = ((PCSettings[16] - 48) * 100) + ((PCSettings[17] - 48) * 10) + ((PCSettings[18] - 48));
  if (Qswitch < 250) {
    Qswitch = 250;
  }
}

void SleepNocommand(void) {

  if (currentTime > (SnappedTimeforPCconnection + 1000)) {
    STOP = 1;
    VNNactive = false;
    VPPactive = false;
    VPPenable = false;
    VNNenable = false;
    SettingPending = true;
    SleepNocommandTimer.end();
  }


}

































