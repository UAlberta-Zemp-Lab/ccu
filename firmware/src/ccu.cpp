/* CCU U1 Code
 * This code runs on the micro on the CCU board. It performs the following:
 *   1. Opens a virtual COM port for PC and T/R commands and data with the PC
 *   2. Creates serial control commands for the U6, and receive U6 stats (other
 *      arduino on the CCU board)
 *   3. Connects to and controls all the PiCards
 *   4. Monitors negative voltage, HV1, and HV2
 *   5. Counts sequences
 */

#include <Arduino.h>

#define SigGen Serial1 // comm between signal generator and the hub
#define Card1  Serial2 // Card port
#define Card2  Serial3 // Card port
#define Card3  Serial4 // Card port
#define Card4  Serial5 // Card port
#define PC     Serial  // Virtual serial

// Timers
IntervalTimer ledBlinkTimer;       // for HV LED!
IntervalTimer SleepNocommandTimer; // if connection is lost, goto safety mode!

// Pin namings
const byte VoltageOKPin =
    2; // this pin is input, will be 1 when negative power supply is connected.
const byte TriggerPin = 3;   // TriggerPin 1 input will be here,cards will have
                             // totally different TriggerPin generated by SigGen
const byte SigGenOKPin = 4;  // this pin is Output and will give sumbs UP, if 1,
                             // then SigGen will work!
const byte VPPenablePin = 5; // Enable output for VPP, OUtput
const byte VNNenablePin = 6;
const byte Card1OKPin = 12; // input, will be TriggerPined by card!
const byte Card2OKPin = 11;
const byte Card3OKPin = 10;
const byte Card4OKPin = 9;
const byte HVLEDPin = 13;
const int VPPreadPin = A4;
const int VNNreadPin = A5;

volatile byte VNN = 0;
volatile byte VPP = 0;
volatile word VPPc = 0;
volatile word VNNc = 0;

volatile bool VPPenable = false;
volatile bool VNNenable = false;
volatile bool VPPactive = false;
volatile bool VNNactive = false;

volatile byte VPPread = 0;
volatile byte VNNread = 0;
byte VNNc1 = 0;
byte VPPc1 = 0;
byte VNNc2 = 0;
byte VPPc2 = 0;
byte VNNc3 = 0;
byte VPPc3 = 0;
byte VNNc4 = 0;
byte VPPc4 = 0;

volatile bool ImgMd;       // 0: US, 1: PA
volatile bool STOP = true; // at the beginning stop signal generation
volatile bool Initialized; // this will be 1 if it is not initiating! zero for
                           // the begining, zero it after receving Seq form PC
volatile bool Operation;
volatile word TrOd = 50; // Dummy value
volatile word Qswitch = 500;

volatile bool HVLED = 0;         // used for controlling the LED!
volatile bool VoltageOK = false; // if negative voltage is applied!
volatile bool Card1status = 0;   // cards status will be here!
volatile bool Card2status = 0;   // cards status will be here!
volatile bool Card3status = 0;   // cards status will be here!
volatile bool Card4status = 0;   // cards status will be here!
byte PCResponse[64];     // contains the most up to date card info ready to send
byte SigGenResponse[64]; // contains the most up to date info for the signal
                         // generator
volatile word SeqCount = 0;
// byte Card1Seq[512][32]; // all the squence information for the card 1
// byte Card2Seq[512][32]; // all the squence information for the card 2
// byte Card3Seq[512][32]; // all the squence information for the card 3
// byte Card4Seq[512][32]; // all the squence information for the card 4
// byte PCseq[2048][64];   // this will store all the sequence information
byte PCSettings[64];
volatile bool SettingPending = false;
volatile bool VoltageSettingsPending = false;
bool CardPogrammingPending = false;
bool ManualTimerStatus =
    false; // used to generate delay without keeping the CPU Busy
unsigned long TimeStamp = 0;
unsigned long TimeStampforPCconnection = 0;
volatile word MaxSeq = 0; // updated as soon as we receive the sequence bytes
unsigned long currentTime = 0;
volatile bool HVlevelError = false;

void
blinkLED(void)
{
	if (HVLED)
		digitalWrite(HVLEDPin, !digitalRead(HVLEDPin));
	else
		digitalWrite(HVLEDPin, LOW);
}

void
readHVlevels(void)
{
	int readinput;

	readinput = analogRead(VPPreadPin);
	VPPread = readinput * 0.477;
	readinput = analogRead(VNNreadPin);
	VNNread = readinput * 0.806451612903;
}

void
SleepNocommand(void)
{
	if (currentTime <= (TimeStampforPCconnection + 1000))
		return;
	STOP = true;
	VNNactive = false;
	VPPactive = false;
	VPPenable = false;
	VNNenable = false;
	SettingPending = true;
	SleepNocommandTimer.end();
}

void
Trigger1Interrupt(void)
{

	SeqCount++;
	if (SeqCount > MaxSeq)
		SeqCount = 0;
	if (!Initialized) {
		SeqCount = 0; // if we received new sequence, this will be zero,
		              // so we can start from seq 0!
		Initialized = 1; // it is initiated!, it it can count again!
	}
}

void
respondToPC(void)
{
	char inbytes[64];
	byte A, B[32], localVPP, localVNN;
	word S, G;
	byte inKey[64] = { 54,  122, 105, 105, 101, 117, 74, 108, 85,  101, 55,
		           107, 97,  109, 104, 78,  97,  52, 115, 104, 112, 82,
		           102, 103, 122, 67,  98,  106, 66, 55,  84,  118, 119,
		           48,  68,  65,  105, 100, 74,  49, 102, 71,  57,  100,
		           81,  103, 82,  80,  56,  55,  87, 110, 79,  50,  114,
		           98,  117, 115, 108, 84,  110, 50, 101, 50 };
	byte outKey[64] = { 54,  101, 116, 116, 117, 74,  108, 85,  101, 55,
		            107, 97,  109, 104, 78,  97,  52,  115, 104, 112,
		            82,  102, 103, 122, 67,  98,  106, 66,  55,  101,
		            114, 121, 48,  68,  65,  105, 100, 74,  49,  102,
		            71,  57,  100, 81,  103, 82,  80,  56,  55,  87,
		            110, 79,  50,  114, 99,  97,  114, 108, 84,  110,
		            50,  101, 111, 50 };
	bool Error = false;

	PC.readBytes(inbytes, 64);

	if (inbytes[0] == '6' && inbytes[1] == 'z' && inbytes[2] == 'i') {
		for (byte i = 0; i < 64; i++)
			if (inbytes[i] != inKey[i])
				Error = true;
		if (!Error)
			PC.write(outKey, 64);
	}

	if (inbytes[0] == 'S' && inbytes[1] == 'E' && inbytes[2] == 'Q') {
		/* Process Bit Sequence */
		// we have to extract the sequence number and store it in the
		// proper we can extract the current sequence and if it is the
		// same as last sequence, we can initiate a card programing
		// sequence!
		STOP = true; // Stop the process

		// for (byte i = 0; i < 64; i++){
		//	PCseq[S][i] = inbytes[i];
		// }

		// inbytes[0] to 63

		// copy the info
		// for (byte j = 0; j < 64; j++) {
		//	A[j] = PCseq[i][j];
		//}

		B[0] = 'B';
		B[1] = 'i';
		B[2] = 't';
		B[3] = 128; // non ASCII, filler!

		// extract the current sequence
		S = (inbytes[11] - '0') * 1000 + (inbytes[12] - '0') * 100
		    + (inbytes[13] - '0') * 10 + (inbytes[14] - '0');
		G = (inbytes[15] - '0') * 1000 + (inbytes[16] - '0') * 100
		    + (inbytes[17] - '0') * 10 + (inbytes[18] - '0');
		MaxSeq = G;

		B[4] = highByte(S);
		B[5] = lowByte(S);
		B[6] = 128; // non ASCII, filler!
		B[7] = highByte(MaxSeq);
		B[8] = lowByte(MaxSeq);
		B[9] = 128; // non ASCII, filler!

		// extract the settings
		for (byte k = 0; k < 16; k++) {
			// start fom byte 10 and write up to byte
			// 25!, will extract fom byte 19 to 50
			bitWrite(B[k + 10], 7,
			         bitRead(inbytes[(k * 2) + 19], 0));
			bitWrite(B[k + 10], 6,
			         bitRead(inbytes[(k * 2) + 19], 1));
			bitWrite(B[k + 10], 5,
			         bitRead(inbytes[(k * 2) + 19], 2));
			bitWrite(B[k + 10], 4,
			         bitRead(inbytes[(k * 2) + 19], 3));
			bitWrite(B[k + 10], 3,
			         bitRead(inbytes[(k * 2) + 20], 0));
			bitWrite(B[k + 10], 2,
			         bitRead(inbytes[(k * 2) + 20], 1));
			bitWrite(B[k + 10], 1,
			         bitRead(inbytes[(k * 2) + 20], 2));
			bitWrite(B[k + 10], 0,
			         bitRead(inbytes[(k * 2) + 20], 3));
		}

		/* fill the rest of the buffer with non-ASCII padding */
		for (byte k = 26; k < 32; k++)
			B[k] = 128;

		/* Send sequence to specified card */
		switch (inbytes[9]) {
		case 'A':
			if (!digitalRead(Card1OKPin))
				Card1.write(B, 32);
			break;
		case 'B':
			if (!digitalRead(Card2OKPin))
				Card2.write(B, 32);
			break;
		case 'C':
			if (!digitalRead(Card3OKPin))
				Card3.write(B, 32);
			break;
		case 'D':
			if (!digitalRead(Card4OKPin))
				Card4.write(B, 32);
			break;
		}

		S = (inbytes[59] - '0') * 1000 + (inbytes[60] - '0') * 100
		    + (inbytes[61] - '0') * 10 + (inbytes[62] - '0');

		G = G * 4;
		if (S == G) {
			// if the last sequence came in, we have to perform a
			// card programming sequnce.
			MaxSeq = G / 4;
			CardPogrammingPending = true;
		}
		PC.write(inbytes, 64);
	}

	if (inbytes[0] == 'C' && inbytes[1] == 'C' && inbytes[2] == 'U') {
		/* Settings cmd: extract and store sequence number */
		for (byte i = 0; i < 64; i++)
			PCSettings[i] = inbytes[i];
		VPPactive = true;
		VNNactive = true;
		SettingPending = true;
		PC.write(inbytes, 64);
	}

	if (inbytes[0] == 'U' && inbytes[1] == 'p' && inbytes[2] == 'd') {
		/* Update cmd */
		A = inbytes[10] - '0';
		STOP = bitRead(A, 0);
		A = inbytes[11] - '0';
		Operation = bitRead(A, 0);
		A = inbytes[12] - '0';
		Initialized = bitRead(A, 0);
		// PC.write(inbytes, 64);
		localVPP = inbytes[15] - 1;
		localVNN = inbytes[16] - 1;
		if ((localVPP != VPP) || (localVNN != VNN)) {
			STOP = true;
			VPP = localVPP;
			VNN = localVNN;
			VoltageSettingsPending = true;
		} else {
			if (STOP) {
				VPPenable = false;
				VNNenable = false;
			} else {
				VPPenable = true;
				VNNenable = true;
			}
		}
		PC.write(PCResponse, 64);
	}
	TimeStampforPCconnection = millis();
	SleepNocommandTimer.begin(SleepNocommand, 1000000); // one second!
}

// Signal generator sent command
// FIXME: untested
void
respondToSigGen(void)
{
	byte A[64];
	byte C = 0;
	while (C == 0) {
		SigGen.write(SigGenResponse, 64);
		C++;
		while (SigGen.available() == 0)
			;
		SigGen.readBytes(A, 64);
		for (byte y = 0; y < 32; y++)
			// resend if wrong info
			if (A[y] != SigGenResponse[y])
				C = 0;
	}
}

#if 0
void
respondToCard2(void)
{
	byte A[32];
	byte C = 0;
	byte j = 0;

	while ((C < MaxSeq) && (!digitalRead(Card2OKPin))) {
		Card2.write(Card2Seq[C], 32);
		while (Card2.available() == 0)
			;
		Card2.readBytes(A, 32);
		C++;
		j = C - 1;
		for (byte y = 0; y < 32; y++)
			// resend if wrong info
			if (A[y] != Card2Seq[C][y])
				C = j;
	}
}

void
respondToCard3(void)
{
	byte A[32];
	byte C = 0;
	byte j = 0;

	while ((C < MaxSeq) && (!digitalRead(Card3OKPin))) {
		Card3.write(Card3Seq[C], 32);
		while (Card3.available() == 0)
			;
		Card3.readBytes(A, 32);
		C++;
		j = C - 1;
		for (byte y = 0; y < 32; y++)
			// resend if wrong info
			if (A[y] != Card3Seq[C][y])
				C = j;
	}
}

void
respondToCard4(void)
{
	byte A[32];
	byte C = 0;
	byte j = 0;

	while ((C < MaxSeq) && (!digitalRead(Card4OKPin))) {
		Card4.write(Card4Seq[C], 32);
		while (Card4.available() == 0)
			;
		Card4.readBytes(A, 32);
		C++;
		j = C - 1;
		for (byte y = 0; y < 32; y++)
			// resend if wrong info
			if (A[y] != Card4Seq[C][y])
				C = j;
	}
}
#endif

/* Prepare byte buffers for transfer
 *
 *   1. Update Response for PC
 *   2. Update response for SigGen
 *   3. General Update response for Cards
 *
 *   Structure for PC responses (ALL as Char)
 *   Byte 0 to 9 > 'UpdateComm'
 *   byte 10:13 > reserved (48)
 *   byte 14 > VNNenable  (48 if disable, 49 if enabled)
 *   byte 15 > VPPenable  (48 if disable, 49 if enabled)
 *   byte 16 > VNNactive
 *   byte 17 > VPPactive
 *   byte 18:20 > VNN read
 *   byte 21:23 > VPP read
 *   byte 24  > Card 1 connect
 *   byte 25  > Card 2 connect
 *   byte 26  > Card 3 connect
 *   byte 27  > Card 4 connect
 *   byte 28:30 > Card 1 VNN
 *   byte 31:33 > Card 1 VPP
 *   byte 34:36 > Card 2 VNN
 *   byte 37:39 > Card 2 VPP
 *   byte 40:42 > Card 3 VNN
 *   byte 43:45 > Card 3 VPP
 *   byte 46:48 > Card 4 VNN
 *   byte 49:51 > Card 4 VPP
 *   byte 52:55 > currentSequence
 *   byte 56:59 > reserved
 *   byte 60    > HVLevelError status byte
 *   byte 61    > Negative Voltage OK status byte
 *   byte 62    > STOP status byte
 *   byte 63    > reserved
 *
 *   Structure for Signal Generator
 *   byte 0:5 > 'SigGen'
 *   byte 6   > STOP
 *   byte 7   > ImgMd
 *   byte 8   > Initialized
 *   byte 9   > Operation
 *   byte 10:11> TrOd
 *   byte 12:13> Qswitch
 *   byte 14> VPP
 *   byte 15> VNN
 *   byte 16:17>VPPc
 *   byte 18:19>VNNc
 *   byte 20:64> reserved
 */
void
prepareBytesForTransfer(void)
{
	/* "UpdateComm" */
	PCResponse[0] = 'U';
	PCResponse[1] = 'p';
	PCResponse[2] = 'd';
	PCResponse[3] = 'a';
	PCResponse[4] = 't';
	PCResponse[5] = 'e';
	PCResponse[6] = 'C';
	PCResponse[7] = 'o';
	PCResponse[8] = 'm';
	PCResponse[9] = 'm';

	/* Reserved */
	PCResponse[10] = '0';
	PCResponse[11] = '0';
	PCResponse[12] = '0';
	PCResponse[13] = '0';

	/* Voltage Status */
	PCResponse[14] = '0' + VNNenable;
	PCResponse[15] = '0' + VPPenable;
	PCResponse[16] = '0' + VNNactive;
	PCResponse[17] = '0' + VPPactive;

	/* Measured VNN */
	PCResponse[18] = '0' + VNNread / 100;
	PCResponse[19] = '0' + VNNread % 100 / 10;
	PCResponse[20] = '0' + VNNread % 10;

	/* Measured VPP */
	PCResponse[21] = '0' + VPPread / 100;
	PCResponse[22] = '0' + VPPread % 100 / 10;
	PCResponse[23] = '0' + VPPread % 10;

	/* PiCard Status */
	PCResponse[24] = '0' + Card1status;
	PCResponse[25] = '0' + Card2status;
	PCResponse[26] = '0' + Card3status;
	PCResponse[27] = '0' + Card4status;

	/* Card 1 VNN and VPP Levels */
	PCResponse[28] = '0' + VNNc1 / 100;
	PCResponse[29] = '0' + VNNc1 % 100 / 10;
	PCResponse[30] = '0' + VNNc1 % 10;

	PCResponse[31] = '0' + VPPc1 / 100;
	PCResponse[32] = '0' + VPPc1 % 100 / 10;
	PCResponse[33] = '0' + VPPc1 % 10;

	/* Card 2 VNN and VPP Levels */
	PCResponse[34] = '0' + VNNc2 / 100;
	PCResponse[35] = '0' + VNNc2 % 100 / 10;
	PCResponse[36] = '0' + VNNc2 % 10;

	PCResponse[37] = '0' + VPPc2 / 100;
	PCResponse[38] = '0' + VPPc2 % 100 / 10;
	PCResponse[39] = '0' + VPPc2 % 10;

	/* Card 3 VNN and VPP Levels */
	PCResponse[40] = '0' + VNNc3 / 100;
	PCResponse[41] = '0' + VNNc3 % 100 / 10;
	PCResponse[42] = '0' + VNNc3 % 10;

	PCResponse[43] = '0' + VPPc3 / 100;
	PCResponse[44] = '0' + VPPc3 % 100 / 10;
	PCResponse[45] = '0' + VPPc3 % 10;

	/* Card 4 VNN and VPP Levels */
	PCResponse[46] = '0' + VNNc4 / 100;
	PCResponse[47] = '0' + VNNc4 % 100 / 10;
	PCResponse[48] = '0' + VNNc4 % 10;

	PCResponse[49] = '0' + VPPc4 / 100;
	PCResponse[50] = '0' + VPPc4 % 100 / 10;
	PCResponse[51] = '0' + VPPc4 % 10;

	/* Current sequence number */
	PCResponse[52] = '0' + SeqCount / 1000;
	PCResponse[53] = '0' + SeqCount % 1000 / 100;
	PCResponse[54] = '0' + SeqCount % 100 / 10;
	PCResponse[55] = '0' + SeqCount % 10;

	/* Reserved */
	PCResponse[56] = '0';
	PCResponse[57] = '0';
	PCResponse[58] = '0';
	PCResponse[59] = '0';

	/* Status Bytes */
	PCResponse[60] = '0' + HVlevelError;
	PCResponse[61] = '0' + VoltageOK;
	PCResponse[62] = '0' + STOP;

	/* Reserved */
	PCResponse[63] = '0';

	/* "SigGen" */
	SigGenResponse[0] = 'S';
	SigGenResponse[1] = 'i';
	SigGenResponse[2] = 'g';
	SigGenResponse[3] = 'G';
	SigGenResponse[4] = 'e';
	SigGenResponse[5] = 'n';

	/* Status Bytes */
	SigGenResponse[6] = '0' + STOP;
	SigGenResponse[7] = '0' + ImgMd;
	SigGenResponse[8] = '0' + Initialized;
	SigGenResponse[9] = '0' + Operation;

	/* TrOd */
	SigGenResponse[10] = highByte(TrOd);
	SigGenResponse[11] = lowByte(TrOd);

	/* Qswitch */
	SigGenResponse[12] = highByte(Qswitch);
	SigGenResponse[13] = lowByte(Qswitch);

	/* Voltage Status */
	SigGenResponse[14] = VPP;
	SigGenResponse[15] = VNN;
	SigGenResponse[16] = highByte(VPPc);
	SigGenResponse[17] = lowByte(VPPc);
	SigGenResponse[18] = highByte(VNNc);
	SigGenResponse[19] = lowByte(VNNc);
	SigGenResponse[20] = '0' + VPPactive;
	SigGenResponse[21] = '0' + VNNactive;

	/* reserved */
	for (int i = 22; i < 64; i++)
		SigGenResponse[i] = '0';
}

/*calculating the sequences for all cards!
  PCseq will contain exact copy of input sequence info
    there will four times arrays comming!
    every card has their own settings!
    Card 1 > byte 9 will be 65
    Card 2 > byte 9 will be 66
    Card 3 > byte 9 will be 67
    Card 4 > byte 9 will be 68
*/

#if 0
void
calculateCardsInfo(void)
{
	// MaxSeq;
	byte A[64];
	byte B[32]; // stores the extracted bytes and will be stored in cards acumulator
	word S;     // contains the current sequnece
	word LocMaxSeq = MaxSeq * 4; // contains the actual received number of the sequences

	for (word i = 0; i < LocMaxSeq; i++) {
		// copy the info
		for (byte j = 0; j < 64; j++)
			A[j] = PCseq[i][j];

		B[0] = 'B';
		B[1] = 'i';
		B[2] = 't';
		B[3] = 128; // non ASCII, filler!

		// extract the current sequence
		S = (A[11] - '0') * 1000 +
		    (A[12] - '0') * 100 +
		    (A[13] - '0') * 10 +
		    (A[14] - '0');

		B[4] = highByte(S);
		B[5] = lowByte(S);
		B[6] = 128; // non ASCII, filler!
		B[7] = highByte(MaxSeq);
		B[8] = lowByte(MaxSeq);
		B[9] = 128; // non ASCII, filler!

		// extract the settings
		for (byte k = 0; k < 16; k++) {
			// start fom byte 10 and write up to byte
			// 25!, will extract fom byte 19 to 50
			bitWrite(B[k + 10], 0, bitRead(A[(k * 2) + 19], 0));
			bitWrite(B[k + 10], 1, bitRead(A[(k * 2) + 19], 1));
			bitWrite(B[k + 10], 2, bitRead(A[(k * 2) + 19], 2));
			bitWrite(B[k + 10], 3, bitRead(A[(k * 2) + 19], 3));
			bitWrite(B[k + 10], 4, bitRead(A[(k * 2) + 20], 0));
			bitWrite(B[k + 10], 5, bitRead(A[(k * 2) + 20], 1));
			bitWrite(B[k + 10], 6, bitRead(A[(k * 2) + 20], 2));
			bitWrite(B[k + 10], 7, bitRead(A[(k * 2) + 20], 3));
		}

		// fill the rest! reserved for future!
		for (byte k = 26; k < 32; k++)
			// non ASCII, filler!
			B[k] = 128;

		// place the structure in the correct card holder
		switch (A[9]) {
		case 'A': // Card 1
			for (byte j = 0; j < 32; j++)
				Card1Seq[S][j] = B[j];
			break;
		case 'B': // Card 2
			for (byte j = 0; j < 32; j++)
				Card2Seq[S][j] = B[j];
			break;
		case 'C': // Card 3
			for (byte j = 0; j < 32; j++)
				Card3Seq[S][j] = B[j];
			break;
		case 'D': // Card 4
			for (byte j = 0; j < 32; j++)
				Card4Seq[S][j] = B[j];
			break;
		}
	}
}
#endif

void
extractPCsettings(void)
{
	// PCSettings
	VNN = PCSettings[3] + 1;
	VPP = PCSettings[4] - 1;
	VPPc = (PCSettings[5] - '0') * 100 + (PCSettings[6] - '0') * 10
	       + (PCSettings[7] - '0');
	VNNc = (PCSettings[8] - '0') * 100 + (PCSettings[9] - '0') * 10
	       + (PCSettings[10] - '0');

	ImgMd = bitRead(PCSettings[11], 3);
	STOP = bitRead(PCSettings[11], 2);
	Initialized = bitRead(PCSettings[11], 1);
	Operation = bitRead(PCSettings[11], 0);

	TrOd = (PCSettings[12] - '0') * 1000 + (PCSettings[13] - '0') * 100
	       + (PCSettings[14] - '0') * 10 + (PCSettings[15] - '0');
	Qswitch = (PCSettings[16] - '0') * 100 + (PCSettings[17] - '0') * 10
	          + (PCSettings[18] - '0');
	if (Qswitch < 250)
		Qswitch = 250;
}

void
setup()
{
	/* configure serial conns */
	PC.begin(9600);
	PC.setTimeout(1);
	SigGen.begin(9600);
	Card1.begin(9600);
	Card2.begin(9600);
	Card3.begin(9600);
	Card4.begin(9600);

	/* configure pins */
	pinMode(SigGenOKPin, OUTPUT);
	pinMode(VPPenablePin, OUTPUT);
	pinMode(VNNenablePin, OUTPUT);
	pinMode(HVLEDPin, OUTPUT);
	pinMode(VoltageOKPin, INPUT);
	pinMode(TriggerPin, INPUT_PULLUP);
	pinMode(Card1OKPin, INPUT_PULLUP);
	pinMode(Card2OKPin, INPUT_PULLUP);
	pinMode(Card3OKPin, INPUT_PULLUP);
	pinMode(Card4OKPin, INPUT_PULLUP);

	/* initialize pins */
	digitalWrite(SigGenOKPin, HIGH);
	digitalWrite(VPPenablePin, LOW);
	digitalWrite(VNNenablePin, LOW);
	digitalWrite(HVLEDPin, LOW);

	/* start timers */
	ledBlinkTimer.begin(blinkLED, 50000);
	SleepNocommandTimer.begin(SleepNocommand, 1000000);

	/* configure interrupts */
	// main trigger, if CCU confirms a delayed trigger out will be created
	// and counted
	attachInterrupt(digitalPinToInterrupt(TriggerPin), Trigger1Interrupt,
	                RISING);
#if 0
	attachInterrupt(digitalPinToInterrupt(Card1OKPin), Card1OKPinInterrupt, RISING); // cards interrups!
	attachInterrupt(digitalPinToInterrupt(Card2OKPin), Card2OKPinInterrupt, RISING);
	attachInterrupt(digitalPinToInterrupt(Card3OKPin), Card3OKPinInterrupt, RISING);
	attachInterrupt(digitalPinToInterrupt(Card4OKPin), Card4OKPinInterrupt, RISING);
#endif
}

void
loop()
{
	byte cardBuf[2];

	VoltageOK = digitalRead(VoltageOKPin);
	Card1status = !digitalRead(Card1OKPin); // cards pull these to GND
	Card2status = !digitalRead(Card2OKPin);
	Card3status = !digitalRead(Card3OKPin);
	Card4status = !digitalRead(Card4OKPin);
	digitalWrite(SigGenOKPin, !STOP);

	readHVlevels();

	if (!VoltageOK)
		STOP = 1;

	/* Blink LED if HV is present */
	if (((VPPread > 25) || (VNNread > 25)) && VoltageOK == true)
		HVLED = true;
	else
		HVLED = false;

	if (SettingPending == true) {
		extractPCsettings();
		prepareBytesForTransfer();
		SettingPending = false;
		SigGen.write(SigGenResponse, 64);
	}

	if (VoltageSettingsPending == true) {
		prepareBytesForTransfer();
		VoltageSettingsPending = false;
		SigGen.write(SigGenResponse, 64);
	}

	if (CardPogrammingPending) {
		/* The last sequence from the PC was recieved.
		 * Wait 100ms without keeping the CPU busy and
		 * then perform a programming sequence!
		 */
		ManualTimerStatus = true;
		TimeStamp = millis();
		CardPogrammingPending = false;
	}

	if ((ManualTimerStatus == true) && ((TimeStamp + 100) > millis())) {
		ManualTimerStatus = false;
		//   calculateCardsInfo(); //extract the information
		/* program cards */
		// respondToCard1();
		// respondToCard2();
		// respondToCard3();
		// respondToCard4();
	}

	prepareBytesForTransfer();
#if 0
	if (Initialized) {
		if ((VPPread > VPP + 5) || (VPPread < VPP - 5) ||
		    (VNNread > VNN + 5) || (VNNread < VNN - 5)) {
			STOP = true;
			VPPenable = false;
			VNNenable = false;
			HVlevelError = true;
		} else {
			HVlevelError = false;
		}
	}
#endif
	digitalWrite(VPPenablePin, VPPenable);
	digitalWrite(VNNenablePin, VNNenable);

	/* check serial conns */
	if (PC.available() > 0)
		respondToPC();
#if 0
	if (SigGen.available() > 0)
		respondToSigGen();
#endif
	if (!Card1status) {
		VNNc1 = 0;
		VPPc1 = 0;
	}
	if (!Card2status) {
		VNNc2 = 0;
		VPPc2 = 0;
	}
	if (!Card3status) {
		VNNc3 = 0;
		VPPc3 = 0;
	}
	if (!Card4status) {
		VNNc4 = 0;
		VPPc4 = 0;
	}
	if (Card1.available() > 0) {
		Card1.readBytes(cardBuf, 2);
		VPPc1 = cardBuf[0];
		VNNc1 = cardBuf[1];
	}
	if (Card2.available() > 0) {
		Card2.readBytes(cardBuf, 2);
		VPPc2 = cardBuf[0];
		VNNc2 = cardBuf[1];
	}
	if (Card3.available() > 0) {
		Card3.readBytes(cardBuf, 2);
		VPPc3 = cardBuf[0];
		VNNc3 = cardBuf[1];
	}
	if (Card4.available() > 0) {
		Card4.readBytes(cardBuf, 2);
		VPPc4 = cardBuf[0];
		VNNc4 = cardBuf[1];
	}

	currentTime = millis();
}
